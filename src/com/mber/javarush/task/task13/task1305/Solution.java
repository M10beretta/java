package com.mber.javarush.task.task13.task1305;

/*
Четыре ошибки
*/

public class Solution {
    public static void main(String[] args) {
        /* static final поле Dream.HOBBY создает статический класс, который создает
        Hobby.INDEX = 1; метод toString делает Hobby.INDEX = 2 */
        System.out.println(Dream.HOBBY.toString());

        /* создается новый объект класса Hobby у которого вызывается toString,
        который инкрементирует Hobby.INDEX */
        System.out.println(new Hobby().toString());

        /*объекты статического класса как фантомы*/
    }

    interface Desire {
    }

    interface Dream {
        Hobby HOBBY = new Hobby();
    }

    // вложенный класс
    static class Hobby implements Desire, Dream {
        // один раз создается статическая переменная Hobby.INDEX = 1
        static int INDEX = 1;

        @Override
        public String toString() {
            INDEX++;
            return "" + INDEX;
        }
    }
}

/*
finetyro
18 уровень
6 мая 2019, 10:40
Ну это совсем уже. ААААА!)

1. Есть статическая переменная INDEX. Она объявлена в классе Hobby.
2. Статической переменной INDEX присвоено в этом же классе начальное значение 1. То есть, когда будет запущено приложение, статическая переменная класса (КЛАССА! НЕ ОБЪЕКТА!) будет уже иметь значение 1.
3. В интерфейсе dream создаётся объект класса Hobby
interface Dream {
    Hobby HOBBY = new Hobby();
}

Он там как создался, так сразу статическим и стал. Это значит, что к нему уже можно обращаться и метод toString, описанный (переопределённый) в классе Hobby вызывать. Что мы и сделали в методе Main:
System.out.println(Dream.HOBBY.toString());

4. После того, как мы вызвали в методе Main метод toString для статического объекта, созданного в интерфейсе, то к изначальному значению статической переменной INDEX (мы же помним, что в классе Hobby изначально заявлено для статической переменной INDEX значение 1) прибавляется единичка. Вуаля! Теперь значение INDEX = 2. Что и выводим.
5. А теперь новый объект класса Hobby уже в методе Main и в новом объекте вызываем метод toString, который снова увеличивает значение статической переменной INDEX на +1. И получается, значение INDEX теперь = 3. Что и выводим.

Что нужно знать, чтобы понять эти пункты:
а) Объекты статических классов можно создавать, а можно и не создавать. Мы создали аж два раза. Первый раз в интерфейсе, второй раз в методе Main.
б) Методу toString в принципе всё равно, из какого объекта класса Hobby его вообще вызывают, он всегда делает одно и то же - прибавляет +1 к статической переменной INDEX, которой, если вспомнить, далеко всё равно, из какого объекта класса Hobby её через метод toString меняют, так-как она находится вне созданных объектов.
в) В интерфейсах оказывается можно объявлять поля (переменные). И даже их инициализировать. Правда, они будут статическими.

Поправьте, если ошибся.)))



Артем
8 апреля 2018, 13:45
По поводу Индекса. Внимательно смотрите на код. Он увеличивается не при создании объекта класса, а в реализации метода toString. То есть при каждом выводе объекта класса он будет увеличиваться.

По поводу обращения к переменной HOBBIE интерфейса. Наш класс поддерживает интерфейс Dream, в котором создается переменная Hobbie HOBBIE. Она создается ОДИН раз и все, как любая статическая переменная. Каждый раз, вызывая HOBBIE.toString(), мы будем выводить на экран один и тот же объект, так как он статический.

Соответственно, в нашей задаче мы сначала выводим на экран статический объект класса HOBBIE, который ЕДИНОЖДЫ создался в интерфейсе и больше не создается. При каждой попытке вывода на экран, мы выводим именно этот объект, а INDEX будет увеличиваться, потому что его инкремент осуществляется при каждом выполнении toString, а не при создании объекта
*/